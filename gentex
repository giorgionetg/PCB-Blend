#!/usr/bin/php
<?php

$opts = getopt("n:p:");

if (!array_key_exists("n", $opts)) {
        print "Usage: gentex -n name\n";
        exit(10);
}

$name = $opts['n'];

if (array_key_exists("p", $opts)) {
    print("Converting PCB to Gerbers ... ");
    $pcb = $opts['p'];
    if (!file_exists($pcb)) {
        print("Error: $pcb not found.\n");
        exit(10);
    }
    system("pcb -x gerber --metric --gerberfile \"$name\" \"$pcb\"");
    system("pcb -x bom --bomfile \"$name.bom\" --xyfile \"$name.xy\" \"$pcb\"");
    print("done\n");
}

print "Converting Gerbers ... ";
generatePreTextures($name);
system("gerbv --border=0 --export=svg \"$name.outline.gbr\" --output=\"$name.outline-segmented.svg\" --foreground='#CC0000' --background='#000000' --dpi=72000");
compactOutline("$name.outline-segmented.svg", "$name.outline.svg");

$topOffset = getSilkOffset($name, "top");
$bottomOffset = getSilkOffset($name, "bottom");

createCroppedSilk($name, "top", $topOffset);
createCroppedSilk($name, "bottom", $bottomOffset);

print "done\n";

function generatePreTextures($name) {
    generatePreTexture($name, "bottom");
    generatePreTexture($name, "bottommask");
    generatePreTexture($name, "bottomsilk");
    generatePreTexture($name, "top");
    generatePreTexture($name, "topmask");
    generatePreTexture($name, "topsilk");
}
    
function generatePreTexture($name, $layer) {
    print($layer . " ... ");
    system("gerbv --border=0 --dpi=2000 --export=png \"$name.outline.gbr\" \"$name.$layer.gbr\" --output=\"$name.$layer.png\" --foreground='#000000' --foreground='#ffffff' --background='#000000'");
    trimImage("$name.$layer.png", 6);
}

function getSilkOffset($name, $layer) {
    system("gerbv --border=0 --dpi=2000 --export=png \"$name.outline.gbr\" \"$name.$layer" . "silk.gbr\" --output=\"$name.$layer" . "silk-outline.png\" --foreground='#ff0000' --foreground='#ffffff' --background='#000000'");

    $img = ImageCreateFromPNG("$name.$layer" . "silk-outline.png");

    $sx = 99999;
    $sy = 99999;

    for ($y = 0; $y < ImageSY($img); $y++) {
        for ($x = 0; $x < ImageSX($img); $x++) {
            $rgb = ImageColorAt($img, $x, $y);
            if ($rgb == 0xB10000) {
                if ($x < $sx) $sx = $x;
                if ($y < $sy) $sy = $y;
            }
        }
    }
    return array($sx, $sy);
}

function compactOutline($in, $out) {
    $doc = new DOMDocument();
    $doc->load($in);

    $paths = $doc->getElementsByTagName("path");

    $pathobjects = array();

    $transform = "";
    $style = "";

    $svg = $doc->getElementsByTagName("svg")->item(0);

    foreach ($paths as $path) {
        $pathdata = $path->getAttribute("d");
        $transform = $path->getAttribute("transform");
        $style = $path->getAttribute("style");
        $ob = parsePathData($pathdata);
        $pathobjects[] = $ob;
    }

    $orderedPaths = array();

    $orderedPaths[] = array_shift($pathobjects);

    while (count($pathobjects) > 0) {

        $lastObject = $orderedPaths[count($orderedPaths)-1];

        $foundone = false;
        $unmatched = array();
        foreach ($pathobjects as $po) {
            if (!$foundone) {
                if (($po->start->x == $lastObject->end->x) && ($po->start->y == $lastObject->end->y)) {
                    $foundone = true;
                    $orderedPaths[] = $po;
                } else if (($po->end->x == $lastObject->end->x) && ($po->end->y == $lastObject->end->y)) {
                    $s = $po->start;
                    $po->start = $po->end;
                    $po->end = $s;
                    if ($po->type == "C") {
                        $cp = $po->cp0;
                        $po->cp0 = $po->cp1;
                        $po->cp1 = $cp;
                    }
                    $foundone = true;
                    $orderedPaths[] = $po;
                } else {
                    $unmatched[] = $po;
                }
            } else {
                $unmatched[] = $po;
            }
        }
        $pathobjects = $unmatched;
        if (!$foundone) {
            print("Error: Nothing found, but objects still exist.");
            break;
        }
    }

    $data = array();
    $last = "";

    foreach ($orderedPaths as $path) {
        if ($last == "") {
            $data[] = "M";
            $data[] = $path->start->x;
            $data[] = $path->start->y;
        }

        switch ($path->type) {
            case 'L':
                if ($last != "L") {
                    $data[] = "L";
                }
                $data[] = $path->end->x;
                $data[] = $path->end->y;
                break;
            case 'C':
                $data[] = "C";
                $data[] = $path->cp0->x;
                $data[] = $path->cp0->y;
                $data[] = $path->cp1->x;
                $data[] = $path->cp1->y;
                $data[] = $path->end->x;
                $data[] = $path->end->y;
                break;
        }

        $last = $path->type;
    }

    $data[] = "Z";

    $width = $svg->getAttribute("width");
    $height = $svg->getAttribute("height");
    $vb = $svg->getAttribute("viewBox");

    $o = array();

    $o[] = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
    $o[] = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"$width\" height=\"$height\" viewBox=\"$vb\" version=\"1.1\">";
    $o[] = "<g id=\"surface1\">";
    $o[] = "<path style=\"$style\" d=\"" . implode(" ", $data) . "\" transform=\"$transform\"/>";
    $o[] = "</g>";
    $o[] = "</svg>";

    file_put_contents($out, implode("\n", $o));
}

function parsePathData($pd) {
    $data = explode(" ", $pd);
    $ob = new stdClass;

    while (count($data) > 0) {
        $bit = array_shift($data);

        switch ($bit) {
            case 'M': // Moveto
                $ob->start = new stdClass;
                $ob->start->x = array_shift($data);
                $ob->start->y = array_shift($data);
                break;

            case 'L': // Lineto
                $ob->end = new stdClass;
                $ob->end->x = array_shift($data);
                $ob->end->y = array_shift($data);
                $ob->type = 'L';
                break;

            case 'C': // Circleto
                $ob->cp0 = new stdClass;
                $ob->cp0->x = array_shift($data);
                $ob->cp0->y = array_shift($data);
                $ob->cp1 = new stdClass;
                $ob->cp1->x = array_shift($data);
                $ob->cp1->y = array_shift($data);
                $ob->end = new stdClass;
                $ob->end->x = array_shift($data);
                $ob->end->y = array_shift($data);
                $ob->type = 'C';
                break;
        }
    }

    return $ob;
}

function createCroppedSilk($name, $layer, $offset) {
    $ox = $offset[0];
    $oy = $offset[1];

    $t = ImageCreateFromPNG($name . ".top.png");
    $sx = ImageSX($t);
    $sy = ImageSY($t);

    $silk = ImageCreateFromPNG($name . "." . $layer . "silk.png");


    $out = ImageCreateTrueColor($sx, $sy);
    ImageCopy($out, $silk, 0, 0, $ox, $oy, $sx, $sy);

    ImagePNG($out, $name . "." . $layer . "silk-cropped.png");
}

function trimImage($image, $amount) {
    $img = ImageCreateFromPNG($image);
    $out = ImageCreateTrueColor(ImageSX($img) - ($amount * 2), ImageSY($img) - ($amount * 2));

    ImageCopy($out, $img, 0, 0, $amount, $amount, ImageSX($out), ImageSY($out));
    ImagePNG($out, $image);
}
